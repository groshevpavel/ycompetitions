# https://ru.wikipedia.org/wiki/Палиндром
#
# алгоритм учитывает набор символов, которые НЕ принимают участия в решении что строка палиндром

pol = ["Я иду с мечем судия", 'Sum summus mus ']
pol += """Кони топот инок
Но не речь, а черен он.
Идем, молод, долом меди.
Чин зван мечем навзничь.
Голод, чем меч долог? """.splitlines()

#print(pol)

# символы которые будут пропущены и НЕ примут участия в решении что строка палиндром
skippers = [' ', "'", ",", ".", "\n", "?", "ь"]

def is_palindrome(s:str, skippers=skippers)->bool:
    """Функция возвращает True в случае если переданная строка палиндром, skippers список символов которые НЕ участвуют в проверке палиндромичности строки"""
    i, len_s = 0, len(s)
    inc_left, inc_right = 0, 0

    # краткое описание работы алгоритма
    # используется "типа-симетричный" проход с начала и конца к центру строки
    # поскольку в случае обнаружения символа который не участвует в принятии решения что строка палиндром
    # проход по строке с двух сторон становится несиметричным, необходимо использовать счетчик несиметричности
    # для каждой из сторон прохода (переменные )
    # i == общая индекс переменная, left, right == индексы символа строки с каждой стороны; left_s, right_s == символы строки в индексах left, right
    #
    # при обнаружении символа НЕ участвующего в принятии решения производится циклическое увеличение соотв. индекса приращения (inc_left, inc_right)
    # поскольку рядом могут быть несколько таких символов используется цикл while(строки 37, 42)

    while True: # решил что while True в данном случае корректнее, потому что условие while i<len_s и так никогда не выполнится :/
        left, right = i + inc_left, (len_s - 1) - i - inc_right

        left_s, right_s = s[left].lower(), s[right].lower()

        while left_s in skippers:
            inc_left += 1
            left = i + inc_left
            left_s = s[left].lower()

        while right_s in skippers:
            inc_right += 1
            right = (len_s - 1) - i - inc_right
            right_s = s[right].lower()


        if left_s != right_s:
            # print(s[left].lower() , s[right].lower(), i, left, right, len_s) # debug print
            return False
        else:
            i += 1

        if left >= right:
            return True


print([is_palindrome(p) for p in pol])

# Результат работы
# ['Я иду с мечем судия', 'Sum summus mus ', 'Кони топот инок', 'Но не речь, а черен он.', 'Идем, молод, долом меди.', 'Чин зван мечем навзничь.', 'Голод, чем меч долог? ']
# [True, True, True, True, True, True, True]

